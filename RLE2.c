#include <stdio.h>
#define N 256 * 256
unsigned char results[N] = {'\0'};

int encoding(unsigned char num[N])
{
    int i, cnt = 1, idx = 0;

    printf("인코딩 후 : ");
    for (i = 0; i < N; i++)
    {
        if (num[i] == 0)
        {
            printf("\n Finish\n");
            break;
        }
        if ((num[i] != num[i + 1]) || (cnt == 15)) //다음 번지의 데이터와 다르거나 반복횟수가 15가 되면 빈 배열에 반복횟수와 데이터를 저장
        {
            results[idx] = num[i];            //데이터를 먼저 집어넣고 shift연산
            results[idx] = results[idx] << 4; //0'b00001111 -> 0'b11110000;
            results[idx] |= cnt;              //데이터를 넣은 배열을 유지하며 cnt값을 넣기위해 ORmasking
            cnt = 1;
            printf("%d%d", results[idx] >> 4, results[idx] & 0b00001111); //앞에 4개의 bit를 없애기위해 ANDmasking
            idx++;
        }
        else
        {
            cnt++;
        }
    }
    return;
}

int decoding(unsigned char en_number[N])
{
    int i, j, idx = 0;
    unsigned char de_number[2 * N] = {
        0,
    };
    unsigned char cnt;
    for (i = 0;; i++)
    {
        if (en_number[i] == 0)
        {
            break;
        }
        cnt = en_number[i] & 0x0F; //저장된 데이터값만큼 반복문을 돌리기 위해 0'b00001111과 ANDmasking
        for (j = 0; j < cnt; j++)
        {
            de_number[idx] = (en_number[i] >> 4) + '0'; //숫자 0~9까지의 값을 넣어야하기 때문에 '0'을 먼저 더해줌
            idx++;
            printf("%d", en_number[i] >> 4); //디코딩과정을 출력하기 위해 오른쪽으로 shift연산한 데이터를 출력
        }
    }
    printf("\n디코딩 결과 : %s\n", de_number);
}

int main()
{
    unsigned char num[N] = {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                            '1', '1', '1', '1', '1', '1', '0', '0',
                            '1', '1', '1', '1', '1', '1', '0', '0', 0};
    printf("인코딩 전 : %s\n", num);
    encoding(num);
    printf("디코딩 과정 : ");
    decoding(results);
    return 0;
}